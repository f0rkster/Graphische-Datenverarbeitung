<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>YoshiX: gfx Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">YoshiX
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">gfx Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates all types and methods of the YoshiX frame work.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgfx_1_1_i_application.html">IApplication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an application which can be run by the render pipeline.  <a href="classgfx_1_1_i_application.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgfx_1_1_s_mesh_info.html">SMeshInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the elements of a mesh.  <a href="structgfx_1_1_s_mesh_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2594f4af34f62830d406887995a864be"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">BHandle</a></td></tr>
<tr class="memdesc:a2594f4af34f62830d406887995a864be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an internal resource of the YoshiX frame work.  <a href="#a2594f4af34f62830d406887995a864be"></a><br/></td></tr>
<tr class="separator:a2594f4af34f62830d406887995a864be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5957a2d01594746c77c0144afff75f64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a5957a2d01594746c77c0144afff75f64">OpenWindow</a> (int _Width, int _Height, const char *_pTitle)</td></tr>
<tr class="memdesc:a5957a2d01594746c77c0144afff75f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a window to render in.  <a href="#a5957a2d01594746c77c0144afff75f64"></a><br/></td></tr>
<tr class="separator:a5957a2d01594746c77c0144afff75f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872254b007213eca4bc6e570c57ed3cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a872254b007213eca4bc6e570c57ed3cd">CloseWindow</a> ()</td></tr>
<tr class="memdesc:a872254b007213eca4bc6e570c57ed3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the window.  <a href="#a872254b007213eca4bc6e570c57ed3cd"></a><br/></td></tr>
<tr class="separator:a872254b007213eca4bc6e570c57ed3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9074859996b77fc9a296678ad80b0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#aca9074859996b77fc9a296678ad80b0f">StartupDirectX</a> ()</td></tr>
<tr class="memdesc:aca9074859996b77fc9a296678ad80b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts up the DirectX render pipeline.  <a href="#aca9074859996b77fc9a296678ad80b0f"></a><br/></td></tr>
<tr class="separator:aca9074859996b77fc9a296678ad80b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f771b87f3c3a164e233940a0b670ed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a1f771b87f3c3a164e233940a0b670ed6">ShutdownDirectX</a> ()</td></tr>
<tr class="memdesc:a1f771b87f3c3a164e233940a0b670ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down the DirectX render pipeline.  <a href="#a1f771b87f3c3a164e233940a0b670ed6"></a><br/></td></tr>
<tr class="separator:a1f771b87f3c3a164e233940a0b670ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cbae4f4b59815966ff8436e5611334"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#ac1cbae4f4b59815966ff8436e5611334">RunApplication</a> (<a class="el" href="classgfx_1_1_i_application.html">IApplication</a> *_pApplication)</td></tr>
<tr class="memdesc:ac1cbae4f4b59815966ff8436e5611334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs an application.  <a href="#ac1cbae4f4b59815966ff8436e5611334"></a><br/></td></tr>
<tr class="separator:ac1cbae4f4b59815966ff8436e5611334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5503e7a976d680eb47728da573361920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a5503e7a976d680eb47728da573361920">StopApplication</a> ()</td></tr>
<tr class="memdesc:a5503e7a976d680eb47728da573361920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the current application.  <a href="#a5503e7a976d680eb47728da573361920"></a><br/></td></tr>
<tr class="separator:a5503e7a976d680eb47728da573361920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f4186b6f91327ac37f3240df34231c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#aa4f4186b6f91327ac37f3240df34231c">SetDepthTest</a> (bool _Flag)</td></tr>
<tr class="memdesc:aa4f4186b6f91327ac37f3240df34231c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates or deactivates the depth test.  <a href="#aa4f4186b6f91327ac37f3240df34231c"></a><br/></td></tr>
<tr class="separator:aa4f4186b6f91327ac37f3240df34231c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7db3624563f003481a8fd75b5bd8679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#ad7db3624563f003481a8fd75b5bd8679">SetWireFrame</a> (bool _Flag)</td></tr>
<tr class="memdesc:ad7db3624563f003481a8fd75b5bd8679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates or deactivates the wire frame mode.  <a href="#ad7db3624563f003481a8fd75b5bd8679"></a><br/></td></tr>
<tr class="separator:ad7db3624563f003481a8fd75b5bd8679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8029d85c8f246685de35497120b32b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#aeb8029d85c8f246685de35497120b32b">SetAlphaBlending</a> (bool _Flag)</td></tr>
<tr class="memdesc:aeb8029d85c8f246685de35497120b32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates or deactivates the alpha blending mode.  <a href="#aeb8029d85c8f246685de35497120b32b"></a><br/></td></tr>
<tr class="separator:aeb8029d85c8f246685de35497120b32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa166e38ebc294b733cd4948c558299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a4fa166e38ebc294b733cd4948c558299">SetClearColor</a> (const float *_pColor)</td></tr>
<tr class="memdesc:a4fa166e38ebc294b733cd4948c558299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the background color of the window.  <a href="#a4fa166e38ebc294b733cd4948c558299"></a><br/></td></tr>
<tr class="separator:a4fa166e38ebc294b733cd4948c558299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5244bccd2b1ad40003124f93ba60028e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a5244bccd2b1ad40003124f93ba60028e">CreateTexture</a> (const char *_pPath, <a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">BHandle</a> *_ppTexture)</td></tr>
<tr class="memdesc:a5244bccd2b1ad40003124f93ba60028e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new texture.  <a href="#a5244bccd2b1ad40003124f93ba60028e"></a><br/></td></tr>
<tr class="separator:a5244bccd2b1ad40003124f93ba60028e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cda91b218c54fabc82fb4c5b65363f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a0cda91b218c54fabc82fb4c5b65363f8">ReleaseTexture</a> (<a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">BHandle</a> _pTexture)</td></tr>
<tr class="memdesc:a0cda91b218c54fabc82fb4c5b65363f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the resources of a texture.  <a href="#a0cda91b218c54fabc82fb4c5b65363f8"></a><br/></td></tr>
<tr class="separator:a0cda91b218c54fabc82fb4c5b65363f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad160add5cb5079c95b2c4e4fce1c8ce3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#ad160add5cb5079c95b2c4e4fce1c8ce3">CreateMesh</a> (const <a class="el" href="structgfx_1_1_s_mesh_info.html">SMeshInfo</a> &amp;_rMeshInfo, <a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">BHandle</a> *_ppMesh)</td></tr>
<tr class="memdesc:ad160add5cb5079c95b2c4e4fce1c8ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mesh.  <a href="#ad160add5cb5079c95b2c4e4fce1c8ce3"></a><br/></td></tr>
<tr class="separator:ad160add5cb5079c95b2c4e4fce1c8ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf99dd21aca2d74c04457922e2f4948d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#adf99dd21aca2d74c04457922e2f4948d">ReleaseMesh</a> (<a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">BHandle</a> _pMesh)</td></tr>
<tr class="memdesc:adf99dd21aca2d74c04457922e2f4948d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the resources of a mesh.  <a href="#adf99dd21aca2d74c04457922e2f4948d"></a><br/></td></tr>
<tr class="separator:adf99dd21aca2d74c04457922e2f4948d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0cfb7c2c91924c2c1e826a741063e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#add0cfb7c2c91924c2c1e826a741063e5">DrawMesh</a> (<a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">BHandle</a> _pMesh)</td></tr>
<tr class="memdesc:add0cfb7c2c91924c2c1e826a741063e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visualizes a mesh.  <a href="#add0cfb7c2c91924c2c1e826a741063e5"></a><br/></td></tr>
<tr class="separator:add0cfb7c2c91924c2c1e826a741063e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87959a7f7bbcbd8d48c206aa0ec89d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a87959a7f7bbcbd8d48c206aa0ec89d59">SetWorldMatrix</a> (const float *_pMatrix)</td></tr>
<tr class="memdesc:a87959a7f7bbcbd8d48c206aa0ec89d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the current world space transformation.  <a href="#a87959a7f7bbcbd8d48c206aa0ec89d59"></a><br/></td></tr>
<tr class="separator:a87959a7f7bbcbd8d48c206aa0ec89d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527c75224d9f33ab028f9b313d3771aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a527c75224d9f33ab028f9b313d3771aa">SetViewMatrix</a> (const float *_pMatrix)</td></tr>
<tr class="memdesc:a527c75224d9f33ab028f9b313d3771aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the transformation from world space into view space.  <a href="#a527c75224d9f33ab028f9b313d3771aa"></a><br/></td></tr>
<tr class="separator:a527c75224d9f33ab028f9b313d3771aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b704705efc7482457473078c9e89f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a18b704705efc7482457473078c9e89f3">SetProjectionMatrix</a> (const float *_pMatrix)</td></tr>
<tr class="memdesc:a18b704705efc7482457473078c9e89f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the transformation from view space into clip space.  <a href="#a18b704705efc7482457473078c9e89f3"></a><br/></td></tr>
<tr class="separator:a18b704705efc7482457473078c9e89f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80df874f594fc8c6268a78d3d38fe157"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a80df874f594fc8c6268a78d3d38fe157">SetLightPosition</a> (const float *_pPosition)</td></tr>
<tr class="memdesc:a80df874f594fc8c6268a78d3d38fe157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the position of the light source in world space.  <a href="#a80df874f594fc8c6268a78d3d38fe157"></a><br/></td></tr>
<tr class="separator:a80df874f594fc8c6268a78d3d38fe157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046b30d4c332d25811422fc490687b15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a046b30d4c332d25811422fc490687b15">SetLightColor</a> (const float *_pAmbientColor, const float *_pDiffuseColor, const float *_pSpecularColor, float _SpecularExponent)</td></tr>
<tr class="memdesc:a046b30d4c332d25811422fc490687b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the properties of the light source.  <a href="#a046b30d4c332d25811422fc490687b15"></a><br/></td></tr>
<tr class="separator:a046b30d4c332d25811422fc490687b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802008b02b1afcdbb9b8a3d0c9f1e3b7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a802008b02b1afcdbb9b8a3d0c9f1e3b7">GetDotProduct2D</a> (const float *_pVector1, const float *_pVector2)</td></tr>
<tr class="memdesc:a802008b02b1afcdbb9b8a3d0c9f1e3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product between two 2D vectors.  <a href="#a802008b02b1afcdbb9b8a3d0c9f1e3b7"></a><br/></td></tr>
<tr class="separator:a802008b02b1afcdbb9b8a3d0c9f1e3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff22e2da4db1cc3fe6d512be9251bfc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#aeff22e2da4db1cc3fe6d512be9251bfc">GetDotProduct3D</a> (const float *_pVector1, const float *_pVector2)</td></tr>
<tr class="memdesc:aeff22e2da4db1cc3fe6d512be9251bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product between two 3D vectors.  <a href="#aeff22e2da4db1cc3fe6d512be9251bfc"></a><br/></td></tr>
<tr class="separator:aeff22e2da4db1cc3fe6d512be9251bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f6a8f964674a2ecd70db184ca27a74"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a64f6a8f964674a2ecd70db184ca27a74">GetDotProduct4D</a> (const float *_pVector1, const float *_pVector2)</td></tr>
<tr class="memdesc:a64f6a8f964674a2ecd70db184ca27a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product between two 4D vectors.  <a href="#a64f6a8f964674a2ecd70db184ca27a74"></a><br/></td></tr>
<tr class="separator:a64f6a8f964674a2ecd70db184ca27a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6f8f713c5b0dbcfa1aa088e9a3d707"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a7b6f8f713c5b0dbcfa1aa088e9a3d707">GetCrossProduct</a> (const float *_pVector1, const float *_pVector2, float *_pResultVector)</td></tr>
<tr class="memdesc:a7b6f8f713c5b0dbcfa1aa088e9a3d707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cross product between two 3D vectors.  <a href="#a7b6f8f713c5b0dbcfa1aa088e9a3d707"></a><br/></td></tr>
<tr class="separator:a7b6f8f713c5b0dbcfa1aa088e9a3d707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659b75013aff150b3c8ec89ef71054b3"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a659b75013aff150b3c8ec89ef71054b3">GetNormalizedVector</a> (const float *_pVector, float *_pResultVector)</td></tr>
<tr class="memdesc:a659b75013aff150b3c8ec89ef71054b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the a 3D vector to the length 1.  <a href="#a659b75013aff150b3c8ec89ef71054b3"></a><br/></td></tr>
<tr class="separator:a659b75013aff150b3c8ec89ef71054b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53c0b264e53a7101a0e268736e391a9"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#aa53c0b264e53a7101a0e268736e391a9">TransformVector</a> (const float *_pVector, const float *_pMatrix, float *_pResultVector)</td></tr>
<tr class="memdesc:aa53c0b264e53a7101a0e268736e391a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a 3D vector by a 4x4 matrix.  <a href="#aa53c0b264e53a7101a0e268736e391a9"></a><br/></td></tr>
<tr class="separator:aa53c0b264e53a7101a0e268736e391a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd9fd02aa3569485d1bd1fecf83e942"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#acbd9fd02aa3569485d1bd1fecf83e942">MulMatrix</a> (const float *_pLeftMatrix, const float *_pRightMatrix, float *_pResultMatrix)</td></tr>
<tr class="memdesc:acbd9fd02aa3569485d1bd1fecf83e942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two 4x4 matrices.  <a href="#acbd9fd02aa3569485d1bd1fecf83e942"></a><br/></td></tr>
<tr class="separator:acbd9fd02aa3569485d1bd1fecf83e942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ec8084e3d9029a47e845cac15d3f58"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a57ec8084e3d9029a47e845cac15d3f58">GetTranslationMatrix</a> (float _X, float _Y, float _Z, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a57ec8084e3d9029a47e845cac15d3f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 translation matrix.  <a href="#a57ec8084e3d9029a47e845cac15d3f58"></a><br/></td></tr>
<tr class="separator:a57ec8084e3d9029a47e845cac15d3f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef7f2087e613503db578fe1c6892132"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a5ef7f2087e613503db578fe1c6892132">GetScaleMatrix</a> (float _Scalar, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a5ef7f2087e613503db578fe1c6892132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 uniform scaling matrix.  <a href="#a5ef7f2087e613503db578fe1c6892132"></a><br/></td></tr>
<tr class="separator:a5ef7f2087e613503db578fe1c6892132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f70f364a688198840ad9b4e299c02b"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#ad1f70f364a688198840ad9b4e299c02b">GetScaleMatrix</a> (float _ScalarX, float _ScalarY, float _ScalarZ, float *_pResultMatrix)</td></tr>
<tr class="memdesc:ad1f70f364a688198840ad9b4e299c02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 scaling matrix.  <a href="#ad1f70f364a688198840ad9b4e299c02b"></a><br/></td></tr>
<tr class="separator:ad1f70f364a688198840ad9b4e299c02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722fce1d717d7ac6a267497d2e953f31"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a722fce1d717d7ac6a267497d2e953f31">GetRotationXMatrix</a> (float _Degrees, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a722fce1d717d7ac6a267497d2e953f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 rotation matrix around the x-axis.  <a href="#a722fce1d717d7ac6a267497d2e953f31"></a><br/></td></tr>
<tr class="separator:a722fce1d717d7ac6a267497d2e953f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18874b5ad14fca0eb337801f59282317"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a18874b5ad14fca0eb337801f59282317">GetRotationYMatrix</a> (float _Degrees, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a18874b5ad14fca0eb337801f59282317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 rotation matrix around the y-axis.  <a href="#a18874b5ad14fca0eb337801f59282317"></a><br/></td></tr>
<tr class="separator:a18874b5ad14fca0eb337801f59282317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177cad1cdbdcc5b63399d4e315d85c18"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a177cad1cdbdcc5b63399d4e315d85c18">GetRotationZMatrix</a> (float _Degrees, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a177cad1cdbdcc5b63399d4e315d85c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 rotation matrix around the z-axis.  <a href="#a177cad1cdbdcc5b63399d4e315d85c18"></a><br/></td></tr>
<tr class="separator:a177cad1cdbdcc5b63399d4e315d85c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bff593a031d915a46fc1cde9850845"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a82bff593a031d915a46fc1cde9850845">GetViewMatrix</a> (float *_pEye, float *_pAt, float *_pUp, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a82bff593a031d915a46fc1cde9850845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 4x4 matrix to transform the world into view space.  <a href="#a82bff593a031d915a46fc1cde9850845"></a><br/></td></tr>
<tr class="separator:a82bff593a031d915a46fc1cde9850845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8adde793a7665f30d8b9929fba0da8"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegfx.html#a7c8adde793a7665f30d8b9929fba0da8">GetProjectionMatrix</a> (float _FieldOfViewY, float _AspectRatio, float _Near, float _Far, float *_pResultMatrix)</td></tr>
<tr class="memdesc:a7c8adde793a7665f30d8b9929fba0da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 4x4 matrix which defines the clip space transformation.  <a href="#a7c8adde793a7665f30d8b9929fba0da8"></a><br/></td></tr>
<tr class="separator:a7c8adde793a7665f30d8b9929fba0da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates all types and methods of the YoshiX frame work. </p>
<p>Encapsulates all types and methods of the YoshiX frame work.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not declare using statements in a header file. </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a2594f4af34f62830d406887995a864be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">gfx::BHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to an internal resource of the YoshiX frame work. </p>
<p>Handle to an internal resource of the YoshiX frame work.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not forget to release created resources again. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a872254b007213eca4bc6e570c57ed3cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::CloseWindow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the window. </p>
<p>Closes the window and frees the resources associated with this window.</p>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ad160add5cb5079c95b2c4e4fce1c8ce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gfx::CreateMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgfx_1_1_s_mesh_info.html">SMeshInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>_rMeshInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">BHandle</a> *&#160;</td>
          <td class="paramname"><em>_ppMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new mesh. </p>
<p>A mesh is a set of triangles. The vertices of the mesh are defined in local space. Each vertex is represented by an array of 3 float values. The topology of the mesh is defined by triangles. Each triangle is represented by three integer indices, where an index corresponds to the position of a vertex in the vertex array. The mesh is represented by a handle which is returned in the last argument.</p>
<p>A mesh can be covered by a surface. The look of the surface is defined by a material. The mesh and the material are defined by the passed mesh info. If the mesh should be lighted, then the mesh info has to contain normals. If the mesh should be textured then the mesh info has to contain texture coordinates and a handle to a texture. Normals, colors, and texture coordinates are defined per vertex their array size has to match the array size of the vertices. Set all elements to null in the mesh info which are not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_rMeshInfo</td><td>The info which defines the elements of the mesh. </td></tr>
    <tr><td class="paramname">_ppMesh</td><td>A pointer to a mesh handle which is filled by the method with a valid mesh handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful otherwise false. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a5244bccd2b1ad40003124f93ba60028e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gfx::CreateTexture </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_pPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">BHandle</a> *&#160;</td>
          <td class="paramname"><em>_ppTexture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new texture. </p>
<p>Creates a new texture. The texture is represented by a handle which is returned in the last argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pPath</td><td>The file path of the texture. </td></tr>
    <tr><td class="paramname">_ppTexture</td><td>A pointer to a texture handle which is filled by the method with a valid texture handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful otherwise false. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="add0cfb7c2c91924c2c1e826a741063e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::DrawMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">BHandle</a>&#160;</td>
          <td class="paramname"><em>_pMesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visualizes a mesh. </p>
<p>Visualizes a mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pMesh</td><td>The handle to the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b6f8f713c5b0dbcfa1aa088e9a3d707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetCrossProduct </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cross product between two 3D vectors. </p>
<p>Takes two 3D input vectors and computes the cross product between them. Each input vector is represented by an array of at least three float values. This means that you can also pass 4D input vectors, but only x, y, and z are considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector1</td><td>The first input vector with at least 3 float values. </td></tr>
    <tr><td class="paramname">_pVector2</td><td>The second input vector with at least 3 float values. </td></tr>
    <tr><td class="paramname">_pResultVector</td><td>The output vector with at least 3 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a802008b02b1afcdbb9b8a3d0c9f1e3b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gfx::GetDotProduct2D </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dot product between two 2D vectors. </p>
<p>Takes two 2D input vectors and computes the dot product between them. Each input vector is represented by an array of at least two float values. This means that you can also pass 3D or 4D input vectors, but only x and y are considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector1</td><td>The first input vector with at least 2 float values. </td></tr>
    <tr><td class="paramname">_pVector2</td><td>The second input vector with at least 2 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the dot product. </dd></dl>

</div>
</div>
<a class="anchor" id="aeff22e2da4db1cc3fe6d512be9251bfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gfx::GetDotProduct3D </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dot product between two 3D vectors. </p>
<p>Takes two 3D input vectors and computes the dot product between them. Each input vector is represented by an array of at least three float values. This means that you can also pass 4D input vectors, but only x, y, and z are considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector1</td><td>The first input vector with at least 3 float values. </td></tr>
    <tr><td class="paramname">_pVector2</td><td>The second input vector with at least 3 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the dot product. </dd></dl>

</div>
</div>
<a class="anchor" id="a64f6a8f964674a2ecd70db184ca27a74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gfx::GetDotProduct4D </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dot product between two 4D vectors. </p>
<p>Takes two 4D input vectors and computes the dot product between them. Each input vector is represented by an array of at least four float values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector1</td><td>The first input vector with at least 4 float values. </td></tr>
    <tr><td class="paramname">_pVector2</td><td>The second input vector with at least 4 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the dot product. </dd></dl>

</div>
</div>
<a class="anchor" id="a659b75013aff150b3c8ec89ef71054b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetNormalizedVector </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the a 3D vector to the length 1. </p>
<p>Takes an array of 3 float values as input and normalizes it to the length</p>
<ol type="1">
<li>The result is stored in the last argument, which is an array of 3 float values allocated by the user.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector</td><td>The input vector with 3 float values. </td></tr>
    <tr><td class="paramname">_pResultVector</td><td>The output vector with 3 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c8adde793a7665f30d8b9929fba0da8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_FieldOfViewY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_AspectRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Near</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Far</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 4x4 matrix which defines the clip space transformation. </p>
<p>Defines the view frustum of the observer and returns the corresponding projection matrix. The projection matrix represents the transformation from view space into clip space. The view frustum is defined by 4 values, which are the field of view angle, the aspect ratio, the near clipping plane, and the far clipping plane. The field of view angle is the angle spawned by the upper and the lower clipping plane of the view frustum. The angle is passed in degrees. The aspect ratio is defined by width / height of the window area. The dimensions width and height are measured in pixels. The near value defines the distance from the observer's eye position to the near clipping plane. The far value defines the distance from the observer's eye position to the far clipping plane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_FieldOfViewY</td><td>The angle spawned by upper and lower clipping plane in degrees. </td></tr>
    <tr><td class="paramname">_AspectRatio</td><td>The ratio between width and height of the window area. </td></tr>
    <tr><td class="paramname">_Near</td><td>The distance from the eye position to the near clipping plane. </td></tr>
    <tr><td class="paramname">_Far</td><td>The distance from the eye position to the far clipping plane. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a722fce1d717d7ac6a267497d2e953f31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetRotationXMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 rotation matrix around the x-axis. </p>
<p>Takes an input angles in degrees and returns the corresponding 4x4 rotation matrix around the x-axis. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Degrees</td><td>The rotation angle around the x-axis in degrees. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a18874b5ad14fca0eb337801f59282317"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetRotationYMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 rotation matrix around the y-axis. </p>
<p>Takes an input angles in degrees and returns the corresponding 4x4 rotation matrix around the y-axis. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Degrees</td><td>The rotation angle around the y-axis in degrees. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a177cad1cdbdcc5b63399d4e315d85c18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetRotationZMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 rotation matrix around the z-axis. </p>
<p>Takes an input angles in degrees and returns the corresponding 4x4 rotation matrix around the z-axis. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Degrees</td><td>The rotation angle around the z-axis in degrees. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ef7f2087e613503db578fe1c6892132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetScaleMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 uniform scaling matrix. </p>
<p>Takes a scaling factor and returns the corresponding 4x4 uniform scaling matrix. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Scalar</td><td>The scaling factor. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1f70f364a688198840ad9b4e299c02b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetScaleMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_ScalarX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_ScalarY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_ScalarZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 scaling matrix. </p>
<p>Takes 3 scaling factors and returns the corresponding 4x4 scaling matrix. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ScalarX</td><td>The scaling factor along the x-axis. </td></tr>
    <tr><td class="paramname">_ScalarY</td><td>The scaling factor along the y-axis. </td></tr>
    <tr><td class="paramname">_ScalarZ</td><td>The scaling factor along the z-axis. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a57ec8084e3d9029a47e845cac15d3f58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetTranslationMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 translation matrix. </p>
<p>Takes a translation 3D vector and returns the corresponding 4x4 translation matrix. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_X</td><td>The translation along the x-axis. </td></tr>
    <tr><td class="paramname">_Y</td><td>The translation along the y-axis. </td></tr>
    <tr><td class="paramname">_Z</td><td>The translation along the z-axis. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a82bff593a031d915a46fc1cde9850845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::GetViewMatrix </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pEye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 4x4 matrix to transform the world into view space. </p>
<p>Takes the observer coordinate system to compute a look-at matrix, which transforms vertices from world space into view space. The observer coordinate system is defined by 3 input vectors, all passed as an array of 3 float values. The eye vector defines the position of the observer in the world. The at vector defines a point in the world, where the observer is looking to. The at vector does not have to be normalized. The view direction is calculated by normalize(at - eye). The up vector defines the orientation of the observer around the view direction. The result is stored in the last argument, which is an array of 16 float values allocated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pEye</td><td>The world space position of the observer passed by 3 float values. </td></tr>
    <tr><td class="paramname">_pAt</td><td>A point in world space where the observer is looking at passed by 3 float values. </td></tr>
    <tr><td class="paramname">_pUp</td><td>The orientation of the observer around the view direction passed by 3 float values. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="acbd9fd02aa3569485d1bd1fecf83e942"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::MulMatrix </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pLeftMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pRightMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies two 4x4 matrices. </p>
<p>Takes a left and a right 4x4 matrix and multiplies them. Matrices are passed an array of 16 float values. The result is stored in the last argument, which is an array of 16 float values allocated by the user. </p>
<pre class="fragment">M = L * R
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pLeftMatrix</td><td>The left input matrix with 16 float values. </td></tr>
    <tr><td class="paramname">_pRightMatrix</td><td>The right input matrix with 16 float values. </td></tr>
    <tr><td class="paramname">_pResultMatrix</td><td>The output matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output matrix. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
<a class="anchor" id="a5957a2d01594746c77c0144afff75f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gfx::OpenWindow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_pTitle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a window to render in. </p>
<p>Opens a window to render in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Width</td><td>The width of the render area in pixels. </td></tr>
    <tr><td class="paramname">_Height</td><td>The height of the render area in pixels. </td></tr>
    <tr><td class="paramname">_pTitle</td><td>The title of the window represented by a '\0' terminated C-string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful otherwise false. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="adf99dd21aca2d74c04457922e2f4948d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gfx::ReleaseMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">BHandle</a>&#160;</td>
          <td class="paramname"><em>_pMesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the resources of a mesh. </p>
<p>Call this method on a mesh to free its resources again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pMesh</td><td>The handle to the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful otherwise false. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cda91b218c54fabc82fb4c5b65363f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gfx::ReleaseTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegfx.html#a2594f4af34f62830d406887995a864be">BHandle</a>&#160;</td>
          <td class="paramname"><em>_pTexture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the resources of a texture. </p>
<p>Call this method on each texture created via CreateTexture to free its resources again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pTexture</td><td>The handle to the texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful otherwise false. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1cbae4f4b59815966ff8436e5611334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gfx::RunApplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgfx_1_1_i_application.html">IApplication</a> *&#160;</td>
          <td class="paramname"><em>_pApplication</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs an application. </p>
<p>Runs an application, i.e. calls the callback methods defined by the <a class="el" href="classgfx_1_1_i_application.html" title="Defines an application which can be run by the render pipeline.">IApplication</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pApplication</td><td>A pointer to the application to be run. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful otherwise false. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb8029d85c8f246685de35497120b32b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetAlphaBlending </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_Flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activates or deactivates the alpha blending mode. </p>
<p>Activates or deactivates the alpha blending mode. If activated pixels with an alpha value lesser than 1 are rendered transparent and blended into the background.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Flag</td><td>If true alpha blending is activated otherwise it is deactivated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful otherwise false. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fa166e38ebc294b733cd4948c558299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetClearColor </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pColor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the background color of the window. </p>
<p>Defines the background color of the window. The window is automatically cleared with this color at the begin of each frame. Colors are defined by an array of 4 float values representing the RGBA channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pColor</td><td>The background color defined by 4 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful otherwise false. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4f4186b6f91327ac37f3240df34231c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetDepthTest </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_Flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activates or deactivates the depth test. </p>
<p>Activates or deactivates the depth test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Flag</td><td>If true the depth test will be activated otherwise deactivated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful otherwise false. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a046b30d4c332d25811422fc490687b15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetLightColor </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pAmbientColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pDiffuseColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pSpecularColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>_SpecularExponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the properties of the light source. </p>
<p>Defines the properties of the light source. The 3 colors are passed as arrays of 4 float values. See the Phong and Blinn lighting equations for better understanding. Specular reflection is calculated by the Blinn equation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pAmbientColor</td><td>The ambient color of the light source with 4 float values. </td></tr>
    <tr><td class="paramname">_pDiffuseColor</td><td>The diffuse color of the light source with 4 float values. </td></tr>
    <tr><td class="paramname">_pSpecularColor</td><td>The specular color of the light source with 4 float values. </td></tr>
    <tr><td class="paramname">_SpecularExponent</td><td>The specular exponent of the Blinn equation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a80df874f594fc8c6268a78d3d38fe157"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetLightPosition </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pPosition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the position of the light source in world space. </p>
<p>Defines the position of the light source in world space. The position is passed as an array of 3 float values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pPosition</td><td>The light position with 3 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a18b704705efc7482457473078c9e89f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the transformation from view space into clip space. </p>
<p>Defines the current active projection matrix, which is used the render pipeline to transform the objects from view space into clip space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pMatrix</td><td>The projection matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd>
<dd>
Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a527c75224d9f33ab028f9b313d3771aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetViewMatrix </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the transformation from world space into view space. </p>
<p>Defines the current active view matrix, which is used the render pipeline to transform the objects from world space into view space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pMatrix</td><td>The projection matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd>
<dd>
Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7db3624563f003481a8fd75b5bd8679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetWireFrame </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_Flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activates or deactivates the wire frame mode. </p>
<p>Activates or deactivates the wire frame mode. If activated meshes are displayed as wire frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Flag</td><td>If true meshes are displayed as wire frames otherwise as solid surfaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful otherwise false. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a87959a7f7bbcbd8d48c206aa0ec89d59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::SetWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the current world space transformation. </p>
<p>Defines the current world space transformation. The transformation is represented by a 4x4 matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pMatrix</td><td>The world matrix with 16 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd>
<dd>
Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f771b87f3c3a164e233940a0b670ed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::ShutdownDirectX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuts down the DirectX render pipeline. </p>
<p>Shuts down the DirectX render pipeline and releases all resources associated with it.</p>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="aca9074859996b77fc9a296678ad80b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gfx::StartupDirectX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts up the DirectX render pipeline. </p>
<p>Starts the DirectX render pipeline.</p>
<dl class="section return"><dt>Returns</dt><dd>true if successful otherwise false. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a5503e7a976d680eb47728da573361920"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfx::StopApplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the current application. </p>
<p>Stops the current application, which will shutdown DirectX and close the window.</p>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="aa53c0b264e53a7101a0e268736e391a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * gfx::TransformVector </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>_pMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>_pResultVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a 3D vector by a 4x4 matrix. </p>
<p>Takes an array of 3 float values as input and transforms it by a 4x4 matrix containing 16 float values. The result is stored in the last argument, which is an array of 3 float values allocated by the user. </p>
<pre class="fragment">V' = V * M
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pVector</td><td>The input vector with 3 float values. </td></tr>
    <tr><td class="paramname">_pMatrix</td><td>The matrix with 16 float values. </td></tr>
    <tr><td class="paramname">_pResultVector</td><td>The output vector with 3 float values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the output vector. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices are in row-major order. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 5 2013 23:43:48 for YoshiX by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
